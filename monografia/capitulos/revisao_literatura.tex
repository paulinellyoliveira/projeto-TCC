\citet{ramos:2016:avaliacao}  avaliaram um \textit{cluster} formado com 16 placas Raspberry Pi, totalizando 64 núcleos e 16GB de memória RAM – memória secundária de 16GB (cartão SD), SO Raspbian, interface de rede de 100Mb/s e todas as placas interligadas por um \textit{switch ethernet} de 100Mb/s com 24 portas, para análise de imagens microscópicas. Essa avaliação compara processadores de baixo custo com CPUs multicores considerando tempo de execução, gasto energético, custo dos equipamentos e performance do \textit{cluster}. Cada raspberry (modelo 2B) possuia: processador Quad Core ARM7 Cortex 900MHz, 1GB RAM, interface de rede 100Mbits/s. Para instalação do SO foram utilizados cartões micro SD 16GB classe 10 (até 80MB/s). O \textit{cluster} foi construído em quatro torres contendo quatro placas em cada e cada fonte de energia (de 5V DC e 2A) alimentou duas placas. Foi utilizada linguagem C++ e a paralelização foi feita utilizando a biblioteca MPI. A execução foi no modelo mestre/escravo. Foram utilizadas como entrada para os testes 512 imagens de 1K x 1K pixels, totalizando 6GB de dados de entrada. Conclui-se que em consumo de energia, a placa (em capacidade máxima de processamento) obteve consumo menor que os computadores (mesmo em estado ocioso: apenas as aplicações do sistema), chegando a 2x menos energia. O \textit{cluster} custou mais caro que os PCs, porém em desempenho ele foi 2x mais rápido que a máquina com processador I7 e 10x mais rápido que a máquina com processador Core2Duo, tornando o \textit{cluster} mais eficiente. Nas avaliações das máquinas, em comparação com uma placa Raspberry Pi, esta apresentou desempenho pior que das máquinas (I7 e Code2Duo). Devido as memórias (primárias e secundárias) da placa serem mais lentas que as dos PCs, operações que realizam muitos acessos as essas memórias fazem com que o desempenho da Raspberry caia se comparado ao dos PCs (por exemplo: operações que visitam muitos pixels vizinhos do ponto analisado dentro de uma imagem). O processamento das imagens se deu pelas seguintes etapas: normalização, segmentação, extração de características, sumarização das características e clusterização.

\citet{lima:2016:implantacao} propôs a análise de desempenho de um \textit{cluster} embarcado de baixo custo composto por processadores da arquitetura ARM e plataforma Raspberry Pi. O trabalho analisava o impacto de usar as bibliotecas MPICH-2 e OpenMPI, executando os programas dos \textit{benchmarks}  HPCC e HPL, a fim de verificar qual implementação obteve um melhor desempenho e um baixo consumo de energia. Os resultados de desempenho e consumo de energia do \textit{cluster} com esses programas mostraram que é possível usar \textit{clusters} de plataformas embarcadas de baixo custo e tendo \textit{speedups} e consumo de energia satisfatórios. 

\citet{godoi:2015:estudo}  apresentou uma comparação de custo/benefício entre um \textit{cluster} de computadores \textit{desktop} tradicionais (computadores HP Compaq 6005 Pro Microtower) e de dispositivos de baixo consumo de energia, como Raspberry Pi Modelo, B e Cubietruck. Para testá-los, foram implementados algoritmos (multiplicação de matrizes MxN e Caixeiro Viajante) para resolução de problemas das classes P e NP-Difícil além do software \textit{benchmark} HP Linpack (HPL). A biblioteca MPI foi utilizada para troca de mensagens. Três \textit{clusters} homogêneos (no formato mestre/escravo) foram montados: computadores \textit{desktop}, Raspberry Pi e Cubietruck. Foram realizadas análises para se obter dados de custo energético (foi desenvolvido um sistema com microcontrolador Tiva e um sensor de corrente), financeiro e velocidade de processamento (para esse parâmetro utilizou-se \textit{speedup} e o \textit{benchmark} HPL). Com os dados coletados de ambos os clusters, foi possível estimar o custo e benefício gerado, bem como verificar sua aplicabilidade. Concluiu-se que os clusters de Raspberry Pi e de Cunietruck têm custo financeiro e consumo energético muito inferior ao de computadores \textit{desktops}. Porém, ao analisar os dados de \textit{speedup} e do HPL, pode-se perceber que a capacidade de processamento do cluster de computadores desktop é superior ao demais. Por fim, concluiu-se, também, que cluster de dispositivos ARM são recomendados para aplicações que necessitam de baixo custo e baixo consumo energético, já cluster de computadores desktops são recomendados para aplicações em que o tempo seja crítico ao sistema e não haja preocupação com custo e consumo (inclusive de refrigeração).

\citet{erckumecka:2015:avaliacao} realizaram a construção de dois \textit{clusters} isolados um do outro: um com sete computadores HP Compaq 6005 Pro Microtower e outro com oito dispositivos ARM (Raspberry Pi), modelo B. Os computadores com distribuição Linux Ubuntu Server e Raspbian para os dispositivos ARM. A biblioteca MPI foi utilizada para a paralelização. Como parâmetros de análise, foram considerados o \textit{benchmark} HP Linpack (HPL), calculo de \textit{speedup}, consumo de energia e custo monetário dos equipamentos. Os cálculos de speedup serão realizados a partir de algoritmos projetados para solucionar problemas, como: \textit{Quick-Sort}, multiplicação de matriz e Caixeiro Viajante utilizando o método GRASP (\textit{Greedy Randomized Adaptive Search Procedure}). Para cálculo do consumo energético foram utilizados sensores de corrente e tensão. Conclui-se que é possível utilizar técnicas de paralelização para equilibrar a inferioridade dos dispositivos embarcados em relação aos computadores convencionais. Sendo assim, é possível criar um sistema computacional distribuído de alto poder de processamento e baixo custo, tanto monetário, quanto energético. Contudo, os dados obtidos após a avaliação mostraram que o \textit{cluster} de Raspberry Pi é inviável para grandes cargas de processamento e com poucos nós.

\citet{nunes:2014:analise} compararam o desempenho de sistemas reais e sistemas emulados em dispositivos com recursos limitados, nesse caso o Raspberry Pi. A análise de desempenho foi realizada em serviços \textit{web} configurados na placa Raspberry Pi (utilizando RESTful e o \textit{framework} CXF) – foram considerados os tempos de processamento de requisições, de empacotamento e desempacotamento de mensagens. Para avaliar o desempenho dos serviços \textit{web}, o seguinte cenário foi proposto: a aplicação cliente gerava uma sequência aleatória de números, enviava para o servidor, que então recebia a mensagem, ordenava esses números e então os enviava de volta ao cliente. Ordenados e após serem recebidos, a aplicação cliente finalizava a conexão com o servidor. Foi utilizado um Raspberry Pi, modelo B com cartão SD de 16GB e SO Linux Raspbian. Para o sistema emulado, foi utilizado o software Qemu, que simulou um hardware equivalente ao do Raspberry e com o mesmo SO. Os experimentos foram realizados 50 vezes (IC de 95\%) com mensagens de 100Kb e 500Kb tanto no sistema real quando no emulado. Uma solução foi implementada para obter tempo de serialização e deserialização e tempo total das aplicações tanto no cliente como no servidor. Conclui-se  que o comportamento no sistema emulado e no sistema real são próximos tanto no cliente como no servidor. No sistema emulado há um leve aumento nos tempos, mas é justificado devido ao custo da emulação.

\citet{crotti:2013:raspberry} propuseram um sistema para acesso remoto utilizando uma placa Raspberry Pi. Foi configurado um servidor \textit{web} na placa que se comunicava com uma pagina \textit{web} (que estava na mesma rede). Através dessa página foi possível o gerenciamento de portas (envio de comandos, acionamento e/ou leitura de portas etc) para o servidor \textit{web} na placa. Também foi configurado uma \textit{webcan} que monitorava os experimentos, isto é, as imagens eram envidas para a placa e esta as enviavam para a internet (\textit{streaming} de vídeo). Foi configurado na placa: pacote lighttpd (um servidor \textit{web}) para servidor de arquivos em C e também PHP, pacote Moiton para o servidor de câmeras (em que cada câmera recebia uma porta de endereço). Na página \textit{web}, foram colocados três botões (acender, apagar e verificar o estado de um LED), além de um quadro que exibe o \textit{streaming} da \textit{webcan}. Cada um desses botões enviava comandos de leitura de arquivos (.C) específicos localizados no servidor de arquivos. Em cada um desses arquivos continham as rotinas e as funções (acender, apagar e verificar).  Observa-se que a aplicação proposta obteve ótimos resultados, inclusive da utilização do Raspberry como servidor, o que possibilita a criação de servidores \textit{web} de baixo custo porém com bom desempenho.

\citet{silva:2012:avaliacao} apresentaram uma implementação do Problema do Caixeiro Viajante na estrutura de um AG de forma paralela utilizando a biblioteca OpenMP e a biblioteca Pthreads. Nessa implementação do AG, cada combinação de rota (passando por todas as cidades) foi definida como um indivíduo, e um conjunto desses indivíduos uma população; cada nó (ou cidade) foi definido como um gene. Assim, quanto maior a população, maior a chance de encontrar uma boa rota, porém maior será o processamento necessário para gerar a próxima geração. Foram gerados conjuntos de populações (ou ilhas) que sofrem a mutação uma independente da outra (a função que realiza a mutação é executada de forma paralela, ou seja, as ilhas sofrem mutações ao mesmo tempo, porém independentes umas das outras). A implementação foi feita em C e cada indivíduo foi representado por um vetor com tamanho igual ao número total de cidades (as coordenadas das cidades estavam em um vetor estático de ponto flutuante também com tamanho igual ao número de cidades) - a população é um vetor de indivíduos. Na implementação, usando a biblioteca pthreads, cada \textit{thread} ficou com uma \textit{struct} e nela havia um vetor de indivíduos (ou população), sendo possível ter as ilhas isoladas umas das outras (pois cada {thread} só acessa sua \textit{struct}). Os testes foram realizados em dois computadores ambos com a mesma distribuição Linux, um com quatro núcleos reais e outro com dois reais (em que cada núcleo real simula dois núcleos lógicos: tecnologia SMP - \textit{Symmetric Multi-Processor}). Foram ajustados: taxas de erro, número máximo de gerações, número de indivíduos em cada população e número de indivíduos na elite. Os resultados mostraram, que no computador com SMP, a implementação com OpenMP obteve melhor resultado que a pthread, enquanto que no computador com quatro núcleos reais, a pthread obteve melhor resultado. Nos dois casos, a implementação paralela obteve resultado significativamente melhor em relação a sequencial. Apesar de que nos cenários propostos a implementação paralela foi melhor que a sequencial, deve-se tomar cuidado ao escolher entre as bibliotecas openMP e pthread, pois cada uma apresentou desempenho melhor em diferentes situações, tornando essencial a análise do problema antes da escolha.

Este trabalho se difere dos demais ao comparar o desempenho com um \textit{notebook} ao invés do computador de mesa e não levar em consideração o consumo de energia. Outra diferença está nas métricas de desempenho utilizadas ($Sd$ e $Ef$, como é apresentado na Seção \ref{secao:metricas}) e a não utilização de aplicações do tipo \textit{benchmark} para análise.